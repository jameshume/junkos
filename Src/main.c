/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>

#include "stm32f401xe.h"


void gpio_a_clk_ena(void)
{
	static bool is_enabled = false;

	if (!is_enabled)
	{
		/* Enable clock to GPIO_A bank */
		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
		is_enabled = true;
	}
}

void led_init(void)
{
	gpio_a_clk_ena();

	/* Set PA5 to be a general purpose push-pull output type */
	/* Make it push pull */
	GPIOA->OTYPER &= GPIO_OTYPER_OT5;

	/* Make it a general purpose output */
	GPIOA->MODER &= ~GPIO_MODER_MODER5;
	GPIOA->MODER |= GPIO_MODER_MODER5_0;
}


void led_set(const bool is_on)
{
	if (is_on)
	{
		GPIOA->ODR |= GPIO_ODR_OD5;
	}
	else
	{
		GPIOA->ODR &= ~GPIO_ODR_OD5;
	}
}

#define GPIO_AFRL_AFSEL2_AF7 (GPIO_AFRL_AFSEL2_0 | GPIO_AFRL_AFSEL2_1 | GPIO_AFRL_AFSEL2_2)
#define GPIO_AFRL_AFSEL3_AF7 (GPIO_AFRL_AFSEL3_0 | GPIO_AFRL_AFSEL3_1 | GPIO_AFRL_AFSEL3_2)

#define GPIO_MODER_ALT_FUNCTION_MODE 2

void uart_init(void)
{
	/* The GPIO_A module is required. */
	gpio_a_clk_ena();

	/* Configure PA2 to be the UART2_TX pin and and PA3 to be the UART2_RX pin. */
	GPIOA->MODER &= ~(GPIO_MODER_MODER2 | GPIO_MODER_MODER3);
	GPIOA->MODER |= (GPIO_MODER_ALT_FUNCTION_MODE << GPIO_MODER_MODER2_Pos) | (GPIO_MODER_ALT_FUNCTION_MODE << GPIO_MODER_MODER3_Pos);
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFSEL2 | GPIO_AFRL_AFSEL3);
	GPIOA->AFR[0] |= GPIO_AFRL_AFSEL2_AF7 | GPIO_AFRL_AFSEL3_AF7;

	/* Enable the clock to the USART 2 module */
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

	USART2->CR1 &= ~USART_CR1_M;     /* 8 data bits, 1 start and n stop bit(s). */
	USART2->CR2 &= ~USART_CR2_STOP;  /* 1 stop bit */
	USART2->CR1 &= ~USART_CR1_OVER8; /* x16 over sampling for robustness to clock deviations */

	/* From 19.3.4: Tx/Rx Baud =             f_ck
	 *                           ----------------------------
	 *                           (8 * (2 - OVER8) * USARTDIV)
	 *
	 * and from figure 167: USARTDIV = DIV_Mantissa + (DIV_Fraction / 8 * (2 - OVER8))
	 *
	 * USARTDIV is an unsigned fixed point number that is coded on the USART_BRR register.
     *     When OVER8=0, the fractional part is coded on 4 bits and programmed by the
     *                   DIV_fraction[3:0] bits in the USART_BRR register
     *     When OVER8=1, the fractional part is coded on 3 bits and programmed by the
     *                   DIV_fraction[2:0] bits in the USART_BRR register, and bit DIV_fraction[3]
     *                   must be kept cleared.
     *
     * I want OVER8 === 0 to increase the tolerance of the receiver to clock deviations, limiting
     * the max speed to f_pclk/16.
     *
     * Initial
     *
     * In my case USARTDIV = DIV_Mantissa + (DIV_Fraction / 16)
     * Thus
     *            Tx/Rx Baud =                     16 MHz
	 *                           ------------------------------------------
	 *                           (16 * (DIV_Mantissa + (DIV_Fraction / 16)))
	 *
	 *                       =                     1 MHz
	 *                           ------------------------------------------
	 *                               (DIV_Mantissa + (DIV_Fraction / 16))
     *
     * Therefore for a particular baud rate...
     *
     *           DIV_Mantissa + (DIV_Fraction / 16) =  1 MHz
     *                                                 ----------
     *                                                    Baud
     *
     * So for a baud of 9600, for example
     *
     *           DIV_Mantissa + (DIV_Fraction / 16) = 1,000,000 / 9,600 = 104.1666....
     *
     *  Therefore DIV_Mantissa = 104
     *  DIV_Fraction = 0.16666... 0.16666... = F / 16 => F = 2.66666,. round to 3
     *
     *  So USARTDIV = (104 << 4) | 3
	 */
	USART2->BRR = ((104 << USART_BRR_DIV_Mantissa_Pos) & USART_BRR_DIV_Mantissa_Msk) |
			      ((3 << USART_BRR_DIV_Fraction_Pos) & USART_BRR_DIV_Fraction_Msk);

	USART2->CR1 |= USART_CR1_UE;     /* Enable the USART */
}


volatile bool txe = true;
void USART2_IRQHandler()
{
	if (USART2->SR & USART_SR_TXE)
	{
		led_set(true);
		txe = true;
		__NVIC_DisableIRQ(USART2_IRQn); // Otherwise we'll continually get this until the next character write...
	}
}


void uart_send_start(void)
{
	USART2->CR1 |= USART_CR1_TE;
	USART2->CR1 |= USART_CR1_TXEIE;
	txe = true;
}


void uart_send_char(const uint8_t c)
{
	/* Wait for the transmit data register to be empty */
	//while((USART2->SR & USART_SR_TXE) == 0) { }
	while(!txe) { }

	/* TX1 == 1, so data has been transferred to the shift register, data register now empty */

	/* Write to the data register - the register bits 31:4 must be kept at their reset value
	 * so do a read/write - could be better and just read those bits once on init but being lazy */
	txe = false;
	led_set(false);
	uint32_t dr_val = USART2->DR;
	dr_val &= ~0xF;
	dr_val |= c;
	USART2->DR = dr_val;
	__NVIC_EnableIRQ(USART2_IRQn);
}

void uart_send_stop(void)
{
	/* Wait for the transmit data register to be empty */
	//while((USART2->SR & USART_SR_TXE) == 0) { }
	while(!txe) { }

	/* Wait for transmission complete */
	while((USART2->SR & USART_SR_TC) == 0) { }

	/* Disable the transmitter */
	USART2->CR1 &= ~USART_CR1_TXEIE;
	USART2->CR1 &= ~USART_CR1_TE;
	__NVIC_DisableIRQ(USART2_IRQn);
}

typedef struct junkos_task_tag
{
	uint8_t priority; /* Low is higher prio */
	bool ready;
	void (*run)(void);
} junkos_task_t;


void send_data_task(void)
{
	static struct {
		unsigned int idx;
	} context = {0};


}


junkos_task_t junkos_tasks[] =	{
	{ 1, true, send_data_task },
};

#define JUNKOS_NUM_TASKS (sizeof(junkos_tasks)/sizeof(junkos_tasks[0]))

typedef uint16_t junkos_task_id_t;
#define JUNKOS_TASK_ID_INVALID UINT16_MAX

void junkos_task_set_runnable(const junkos_task_id_t task_index)
{
	if (task_index < JUNKOS_NUM_TASKS)
	{
		__disable_irq();
		{
			junkos_tasks[task_index].ready = true;
		}
		__enable_irq();
	}
}

junkos_task_id_t junkos_task_get_next_runnable(void)
{
	uint16_t task_id = JUNKOS_TASK_ID_INVALID;

	__disable_irq();
	{
		for(junkos_task_id_t idx = 0; idx < JUNKOS_NUM_TASKS; ++idx)
		{
			if (junkos_tasks[task_index].ready)
			{
				task_id = idx;
				break;
			}
		}
	}
	__enable_irq();

	return task_id;
}



void scheduler(void)
{
	/*
	 * Simple model - tasks are "signalled" which makes them ready to run and thats it.
	 * Signalling a task puts it on the run priority-queue. Once the task has run it is
	 * taken off that queue and simply put on an idle queue.
	 *
	 * Really shitty alg - use a bitmap of tasks. Look each up and select highest priority. No two tasks have same priority!
	 */
	 while(true)
	 {
	    const junkos_task_id_t task_id = junkos_task_get_next_runnable();
	    if (task_id != JUNKOS_TASK_ID_INVALID)
	    {
	    	junkos_tasks[task_id]->run();
	    }
	    else
	    {
	       // Could go to a low power mode -- TODO
	    }
	 }
}


int main(void)
{
	bool led_on = false;

	led_init();
	uart_init();

	led_set(led_on);

	while(true)
	{
		//led_set(led_on);
		//led_on = !led_on;

		uart_send_start();
		uart_send_char('J');
		uart_send_char('E');
		uart_send_char('H');
		uart_send_char('\r');
		uart_send_char('\n');
		uart_send_stop();

		for(int i = 0; i < 100000; ++i) {	}
	}
}
